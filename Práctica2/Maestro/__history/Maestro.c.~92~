// MAESTRO en SPI
#include <16f877a.h>
#fuses XT, NOWDT, PUT, NOPROTECT, BROWNOUT, NOCPD, NOWRT, NODEBUG 
#use delay(crystal=4000000) 
//#use rs232(baud=9600,xmit=PIN_D0,rcv=PIN_D1,stream=PC, parity=N, bits=8) //18F4550
#use rs232(baud=9600,xmit=PIN_C6,rcv=PIN_C7,stream=PC, parity=N, bits=8)//16F887
#define SPI_SS   PIN_C2 
// Modos de comunicación SPI 
#define SPI_MODE_0  (SPI_L_TO_H | SPI_XMIT_L_TO_H) 
// Comandos SPI que acepta el esclavo 
#define CONECTAR          1 


#define use_portb_kbd true
#include <kbd.c>
#include <stdio.h>


//====================================== 
void main() 
{ 
   char aux;
   kbd_init();
   port_b_pullups(true);
   
   
   
   char resultado,c;
   
   output_high(SPI_SS);  // Inicializa el Pin SS en alto para deshabilitar el esclavo
   
   //Inicializa el hardware SSP para ser un SPI Maestro en Modo 0
   setup_spi(SPI_MASTER | SPI_MODE_0 | SPI_CLK_DIV_4); 
   
   printf("Presiona cualquier tecla para conectar con el esclavo:\n\r"); 
  
    
   
   
   while(1) 
   { 
      aux = kbd_getc();
      
      if(aux!=0){
         printf("%X\n\r", aux);
      }
      
      /*-----------------BLOQUE  SPI-----------------
      c = '\0'; //Captura el caracter del puerto serial RS232
      
      if(c!='\0'){
         output_low(SPI_SS); 
         spi_write(CONECTAR);  // Envia el comando 
         output_high(SPI_SS); 
         
         delay_us(100);  // Tiempo para que el esclavo responda
         
         output_low(SPI_SS); 
         resultado = spi_read(0);     // Lee la respuesta del esclavo 
         output_high(SPI_SS); 
         
         printf("%c\n\r", resultado);
      }
      //-----------------BLOQUE  SPI-----------------*/
   }
}
